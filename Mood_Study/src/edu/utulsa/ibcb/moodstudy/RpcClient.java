package edu.utulsa.ibcb.moodstudy;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;

import org.xmlrpc.android.XMLRPCClient;
import org.xmlrpc.android.XMLRPCException;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.preference.PreferenceManager;
import android.util.Base64;

public class RpcClient {

	public static final String USERNAME_OPTION = "username";
	public static final String PASSWORD_OPTION = "password";

	private static final String configFile = ".settings";

	private static final String protocol = "http";
	private static final String RPCserver = "87.106.100.214"; 

	/** name of the php file server side procedure calls are to **/
	public static String RPCscript = "service.php";

	private static RpcClient instance = new RpcClient();

	private boolean loaded = false;
	private XMLRPCClient client = null;
	private ConcurrentHashMap<String, String> options = null;
	

	public static RpcClient getInstance(Context context) {
		instance.ensureLoaded(context);
		return instance;
	}
	
	public void uploadSurveyData(Context ctx, String[] questions, String[] responses)
			throws XMLRPCException {
		
		SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(ctx);
		String username = settings.getString("username","");
		
		String manufacturer = Build.MANUFACTURER;
		String model = Build.MODEL;
		String product = Build.PRODUCT;
		String hardware = Build.HARDWARE;
		String device = Build.DEVICE;
		String software = "" + Build.VERSION.SDK_INT;
		//massage into:  manufacture, model, deviceID
		
		
		//TODO upload: 
		//username, string[] questions, string[] responses, string manufacturer, string model, string deviceID
	
	}
	
	public int[] play() throws XMLRPCException {
		return new int[]{(int)(Math.ceil(6*Math.random())), (int)(Math.ceil(6*Math.random()))};
	}
	
	/**
	 * 
	 * @param luckyFeeling
	 * @param prompt
	 * @param actual
	 * @param timestamps
	 *            of when each data point was collected
	 * @param ax
	 *            accelerometer readings on the x-axis for each data point
	 * @param ay
	 *            accelerometer readings on the y-axis for each data point
	 * @param az
	 *            accelerometer readings on the z-axis for each data point
	 * @param hasGryo
	 * @param gx
	 *            only valid if hasGyro
	 * @param gy
	 *            only valid if hasGyro
	 * @param gz
	 *            only valid if hasGyro
	 */
	public void uploadSensorData(Context ctx, int[] timestamps, double[] ax, double[] ay,
			double[] az, boolean hasGyro, double[] gx, double[] gy, double[] gz)
			throws XMLRPCException {
		
		SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(ctx);
		String username = settings.getString("username","");
		int SID = settings.getInt("SID",-1);
		int initialSurveyActivityResult = settings.getInt("initialSurveyActivityResult",-1);
		
		
		//TODO upload:
		//String username, int SID, initialSurveyActivityResult, int[] timestamps, initialSurveyActivityResult, double[] ax, double[] ay, double[] az, boolean hasGyro, double[] gx, double[] gy, double[] gyz
		
		//Object[] arg_v = { options.get("username"), options.get("password"),
		//		pid, timestamps, ax, ay, az, hasGyro, gx, gy, gz };
		//client.callEx("uploadSensorData", arg_v);
	}
	
	/**
	 * @param controls
	 *            integer[] values from 0-100 generated by asking the user questions
	 **/
	public void uploadFinalSurveyData(Context ctx, String[] questions, int[] responses) throws XMLRPCException {
		
		SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(ctx);
		String username = settings.getString("username","");
		int SID = settings.getInt("SID",-1);
		int initialSurveyActivityResult = settings.getInt("initialSurveyActivityResult",-1);
		
		//TODO upload:
		// username, SID, String[] questions, int[] responses
		
	}


	private Boolean login(String user, String pass) throws XMLRPCException {
		return (Boolean) client.call("login", user, pass);
	}

	///TODO remove anything below this line that isn't needed for RPC functionality
	
	private synchronized void ensureLoaded(Context context) {
		if (!loaded) {
			String url = protocol + "://" + RPCserver /* + ":" + RPCport */+ "/"
					+ RPCscript;
			client = new XMLRPCClient(url, context);
			options = new ConcurrentHashMap<String, String>();

			// temporary measure until a permanent login system is decided upon
			/**/setOptions(context, "username", "matt.matlock@gmail.com",
					"password", "z38lives");

			load(context);
		}
	}

	public synchronized String getOption(String option) {
		if (options.containsKey(option))
			return options.get(option);
		return null;
	}

	private synchronized void deleteOptions(Context context, String... args) {
		for (String option : args) {
			options.remove(option);
		}

		save(context);
	}

	private synchronized void setOptions(Context context, String... args) {
		for (int i = 0; i < args.length; i += 2) {
			options.put(args[i], args[i + 1]);
		}

		save(context);
	}

	private void load(Context context) {
		try {
			FileInputStream fis = context.openFileInput(configFile);

			DataInputStream dataIn = new DataInputStream(fis);

			String line = "";
			while ((line = dataIn.readLine()) != null) {
				if (line.contains("=")) {
					String[] items = line.split("=");

					options.put(items[0], items[1]);
				}
			}

			dataIn.close();
		} catch (FileNotFoundException fnfe) {
			fnfe.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}

		loaded = true;
	}

	private void save(Context context) {
		try {
			FileOutputStream fos = context.openFileOutput(configFile,
					Context.MODE_PRIVATE);
			DataOutputStream dataOut = new DataOutputStream(fos);

			for (String key : options.keySet()) {
				dataOut.writeChars(key + "=" + options.get(key) + "\n");
			}
			dataOut.close();

		} catch (FileNotFoundException fnfe) {
			fnfe.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}

	}

	

}
